<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/prettify.css">
    <link rel="stylesheet" href="css/custom.css">
    <title>Documentación</title>
</head>
<body>

<article class="content-text">
    <h1>Symfony CRUD</h1>
    <h2 class="mt-1">Crear la base de datos</h2>
    <pre class="prettyprint mt-1" style="width: 1100px;">
        CREATE DATABASE IF NOT EXISTS symfony_master;
        USE symfony_master;
        
        CREATE TABLE IF NOT EXISTS users(
        id          int(255) auto_increment not null,
        role        varchar(50),
        name        varchar(100),
        surname     varchar(200),
        email       varchar(255),
        password    varchar(255),
        created_at  datetime,
        CONSTRAINT pk_users PRIMARY KEY(id)
        )ENGINE=InnoDb;
        
        INSERT INTO users VALUES(NULL, 'ROLE_USER', 'Víctor', 'Lopez', 'victor@victor.com', 'password', CURTIME());
        INSERT INTO users VALUES(NULL, 'ROLE_USER', 'Manolo', 'Perez', 'manolo@manolo.com', 'password', CURTIME());
        INSERT INTO users VALUES(NULL, 'ROLE_USER', 'Carlos', 'Sanchez', 'carlos@carlos.com', 'password', CURTIME());
        
        CREATE TABLE IF NOT EXISTS tasks(
        id          int(255) auto_increment not null,
        user_id     int(255) not null,
        title       varchar(255),
        content     text,
        priority    varchar(20),
        hours       int(100),
        created_at  datetime,
        CONSTRAINT pk_tasks PRIMARY KEY(id),
        CONSTRAINT fk_task_user FOREIGN KEY(user_id) REFERENCES users(id)
        )ENGINE=InnoDb;
        
        INSERT INTO tasks VALUES(NULL, 1, 'Tarea 1', 'Contenido de prueba 1', 'high', 40, CURTIME());
        INSERT INTO tasks VALUES(NULL, 1, 'Tarea 2', 'Contenido de prueba 2', 'low', 20, CURTIME());
        INSERT INTO tasks VALUES(NULL, 2, 'Tarea 3', 'Contenido de prueba 3', 'medium', 10, CURTIME());
        INSERT INTO tasks VALUES(NULL, 3, 'Tarea 4', 'Contenido de prueba 4', 'high', 50, CURTIME());
        
    </pre>    
    <h2 class="mt-1">Configuramos la base de datos en .env</h2>
    <p class="single-code mt-1">
        DATABASE_URL=mysql://root@127.0.0.1:3306/symfony_master
    </p>
    <h2 class="mt-1">A partir de la base de datos, generar las Entidades</h2>
    <p class="single-code mt-1">
        php bin/console doctrine:mapping:import App\\Entity annotation --path=src/Entity
    </p>
    <h2 class="mt-1">Generamos los getter and setter con el siguiente comando:</h2>
    <p class="single-code met-1">
        php bin/console make:entity --regenerate App
    </p>
    <p class="mt-1 w-50">Opcional cambiar el nombre de las entidades de Users.php y Tasks.php a 
        User.php y Task.php, también cambiar adentro de los archivos a singular nombre de las
        clases y referencias
    </p>
    <h2 class="mt-1">Requirimiento: Traer todas las tareas creadas por un usuario</h2>
    <p class="mt-1">En Entity/User.php importamos lo siguiente:</p>
    <p class="single-code mt-1">
        use Doctrine\Common\Collections\ArrayCollection;<br>
        use Doctrine\Common\Collections\Collection;
    </p>
    <p class="single-code mt-1">
        En Entity/User.php ponemos lo siguiente:
    </p>
    <pre class="prettyprint mt-1">
        /**
        * @ORM\OneToMany(targetEntity="App\Entity\Task", mappedBy="user")
        */
        private $tasks;


        public function __construct(){
            $this->tasks = new ArrayCollection();
        }
    </pre>
    <p class="mt-1 w-50">
        Y en Entity/Task.php en la propiedad private user agregamos la siguiente anotación:
    </p>
    <p class="single-code mt-1">
        @ORM\ManyToOne(targetEntity="App\Entity\User", inversedBy="tasks")
    </p>
    <h2 class="mt-1 w-50">En Entity/Task.php creamos un método para traer todas las tareas</h2>
    <pre class="prettyprint mt-1">
        /**
        * @return Collection|Task[]
        */
       public function getTasks(): Collection
       {
          return $this->tasks;
       }
    </pre>
    <h2 class="mt-1">Creamos un controlador</h2>
    <p class="mt-1 w-50">
        En Controller/UserController ponemos lo siguiente:
    </p>
    <pre class="prettyprint mt-1">
    public function register()
    {
        return $this->render('user/register.html.twig');
    }
    </pre>
    <h2 class="mt-1">Creamos la vista asociada:</h2>
    <p class="mt-1 w-50">
        Creamos templates/user/register.html.twig
    </p>
    <pre class="prettyprint mt-1">
    {% extends 'base.html.twig' %}

    {% block title %}Registro de usuarios{% endblock %}
    
    {% block body %}
    
    <div class="example-wrapper">
        &#60;h1&#62;Registro de usuarios&#60;/h1&#62;
    </div>
    
    {% endblock %}
    </pre>
    <h2 class="mt-1">Creamos la ruta</h2>
    <p class="mt-1">Abrimos config/routes.yaml para crear una nueva ruta</p>
    <pre class="prettyprint mt-1">
    register:
        path: /registro
        controller: App\Controller\UserController:register
    </pre>
    <h2 class="mt-1">Creamos un formulario</h2>
    <p class="mt-1 w-50">Creamos en src la carpeta Form y dentro el archivo 
        RegisterType.php con el siguiente código:
    </p>
    <pre class="prettyprint mt-1">
    namespace App\Form;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Extension\Core\Type\EmailType;
    use Symfony\Component\Form\Extension\Core\Type\PasswordType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    
    class RegisterType extends App\Form\AbstractType
    {
        public function buildForm(FormBuilderInterface $builder,
                                    array $options)
        {
            $builder->add('name', TextType::class, array(
                'label' => 'Nombre'
            ))
            ->add('surname', TextType::class, array(
                'label' => 'Apellidos'
            ))
            ->add('email', EmailType::class, array(
                'label' => 'Nombre'
            ))
            ->add('password', PasswordType::class, array(
                'label' => 'Contraseña'
            ))
            ->add('submit', SubmitType::class, array(
                'label' => 'Registrarse'
            ));
    
        }
    }
    </pre>
    <p class="mt-1 w-50">
        Este formulario lo utilizaremos en el controlador
    </p>
    <pre class="prettyprint mt-1">
    // Importamos las clases
    use Symfony\Component\Routing\Annotation\Route;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpFoundation\Request;
    
    use App\Entity\User;
    use App\Form\RegisterType;
    
    //Incluimos en el controlador lo siguiente
    public function register(Request $request)
    {
        $user = new User();
        $form = $this->createForm(RegisterType::class, $user);
    
        return $this->render('user/register.html.twig', [
            'form' => $form->createView()
        ]);
    }
    </pre>
    <p class="mt-1 w-50">Utilizamos en formulario en la vista de registro</p>
    <pre class="prettyprint mt-1">
    {% extends 'base.html.twig' %}
    
    {% block title %}Registro de usuarios{% endblock %}
    
    {% block body %}
    
    <div class="example-wrapper">
        &#60;h1&#62;Registro de usuarios&#60;/h1&#62;
        {{ form_start(form) }}
        {{ form_widget(form) }}
        {{ form_end(form) }}
    </div>
    
    {% endblock %}
    </pre>    
    <p class="mt-1 w-50">Para encripta la contraseña configuramos 
        config/packages/security.yaml e incluimos lo siguiente:
    </p>
    <pre class="prettyprint mt-1">
    security:
    encoders:
        App\Entity\User:
            algorithm: bcrypt
            cost: 4
    </pre>
    <p class="mt-1">Configuramos la UserInterface en la Entidad Usuario</p>
    <pre class="prettyprint mt-1">
    // Agregamos el import
    use Symfony\Component\Security\Core\UserInterface;
    
    // La implementamos en la clase
    class User implements UserInterface
    {
        // Añadimos los métodos que obliga la interface
        
        public function getUsername(){
            reurn $this->email;
        }
    
        public funtion getSalt(){
            return null;
        }
    
        public function getRoles(){
            return ['ROLE_USER']; 
        }
    
        public function eraseCredentials(){}
    }
    </pre>
    <p class="mt-1">
        Hacemos un cambio en Entity/User.php
    </p>
    <pre class="prettyprint mt-1">
    // En las siguientes firmas
    public function getCreatedAt(): ?\DateTimeInterface

    public function setCreatedAt(?\DateTimeInterface $createdAt): self
    // Le sacamos el tipado
    
    
    public function getCreatedAt()
    
    public function setCreatedAt($createdAt): self
    </pre>
    <p class="mt-1 w-50">
        Hacemos los siguientes cambios en el controlador
    </p>
    <pre class="prettyprint mt-1">

    // Importamos lo siguiente
    use Symfony\Component\Security\Core\Encoder\UserPasswordEncoderInterface;
    
    // El método register quedaría así
    public function register(Request $request)
    {
        $user = new User();
        $form = $this->createForm(RegisterType::class,
                                    $user, 
                                    UserPasswordEncoderInterface $encoder);
    
        $form->handleRequest($request);
    
        f($form->isSubmitted() && $form->isValid()){
            $user->setRole('ROLE_USER');
            $user->setCreatedAt(new \DateTime('now'));
            $encoded = $encoder->encodePassword($user, $user->getPassword());
            $user->setPassword($encoded);
    
            // Guardar usuario
            $em = $this->getDoctrine()->getManager();
            $em->persist($user);
            $em->flush();
    
            return $this->redirectToRoute('tasks');
        }
    
        return $this->render('user/register.html.twig', [
            'form' => $form->createView()
        ]);
    }
        
    </pre>
    <p class="mt-1 w-50">
        Como agregamos arriba $form->isValid() debemos
        hacer las validaciones en la Entidad User.php
    </p>
    <pre class="prettyprint mt-1">
    // Importamos lo siguiente
    use Symfony\Component\Validator\Constraints as Assert;
    
    // Agregamos las siguientes validaciones
    
    //Agremos la siguiente anotacion a private $name
    
    /**
    * @ORM (Etcétera)
    * @Assert\NotBlank
    * @Assert\Regex("/[a-zA-Z ]+/")
    */
    public $name;
    
    //Idem para $surname
    
    /**
    * @ORM (Etcétera)
    * @Assert\NotBlank
    * @Assert\Regex("/[a-zA-Z ]+/")
    */
    public $surname;
    
    // Para Email
    /**
    * @ORM (Etcétera)
    * @Assert\NotBlank
    * @Assert\Email(
    *     message = "El email ''{{value}}' no es válido",
    *     checkMX = true
    * )
    */
    public $email;
    
    
    // Password no vacía
    
    /**
    * @ORM (Etcétera)
    * @Assert\NotBlank
    */
    public $password;
    
    </pre>
    <h2 class="mt-1">Estilos CSS</h2>
    <p class="mt-1 w-50">
        Creamos los directorios y el archivo:
        public/assets/css/style.css e incluimos los siguiente estilos:
    </p>
    <pre class="prettyprint mt-1">
    body{
        background: white;
    }
    
    .clearfix{
        float:none;
        clear:both;
    }
    
    .example-wrapper { 
        margin: 1em auto; 
        max-width: 800px; 
        width: 95%; 
        font: 18px/1.5 sans-serif;
    }
    
    .example-wrapper code { 
        background: #F5F5F5; 
        padding: 2px 6px; 
    }
    
    #header{
        margin: 1em auto; 
        max-width: 800px; 
        width: 95%; 
        font: 18px/1.5 sans-serif;
    }
    
    #menu{
        margin:0px;
        padding:0px;
        list-style: none;
        width: 100%;
        height: 50px;
        background: #eee;
        line-height: 50px;
    }
    
    #menu li {
        display:block;
        float:left;
        padding-left: 15px;
        padding-right: 15px;
        border-right: 1px solid #ccc;
        cursor: pointer;
        transition: all 300ms;
    }
    
    #menu li.right{
        float:right;
        border-right: 0px;
        border-left: 1px solid #ccc;
    }
    
    
    #menu a{
        display:block;
        color: #444;
        text-decoration: none;
        transition: all 300ms;
    }
    
    
    #menu li:hover {
        background: #444;
    }
    
    #menu li:hover a {
        color: white;
    }
    
    
    
    
    label{
        display: block;
        width: 80%;
        margin-top:15px;
        margin-bottom: 5px;
    }
    
    input[type="text"],
    input[type="password"],
    input[type="email"],
    textarea,
    select{
        width: 70%;
        padding: 8px;
    }
    
    button,
    input[type="submit"]{
        padding:8px;
        margin-top:15px;
        background: #00AA33;
        color: white;
        border: 1px solid #047425;
        cursor:pointer;
        transition: all 300ms;
    }
    
    button:hover,
    input[type="submit"]:hover{
        background: #047425;
    }
    
    table{
        width:100%;
    }
    
    table th,
    table td{
        background: #f6f6f6;
        padding: 15px;
        padding-right: 25px;
        padding-left: 25px;
        border-bottom: 1px solid #eee;
        text-align: center;
    }
    
    table td{
        background: #e9ffea;
    }
    
    .buttons a{
        text-decoration: none;
        border: 1px solid green;
        padding: 10px;
        color: white;
        background: #00AA33;
    }
    
    .buttons{
        width: 33%;
    }
    
    .buttons .btn-edit{
        background: orange;
        border-color: #f38b06;
    }
    
    .buttons .btn-delete{
        background: red;
        border-color: #b90808;
    }
    
    .data-task{
        color:gray;
    }
    </pre>
    <p class="mt-1 w-50">
        Y base.html.twig queda así:
    </p>
    <pre class="prettyprint mt-1" style="width: 1100px;">
    &#60;!DOCTYPE html&#62;
    &#60;html&#62;
        &#60;head&#62;
            &#60;meta charset="UTF-8"&#62;
            &#60;title&#62;{% block title %}Welcome!{% endblock %}&#60;/title&#62;
            {% block stylesheets %}
                &#60;link href="{{ asset('assets/css/style.css') }}" type="text/css" rel="stylesheet" /&#62;
            {% endblock %}
        &#60;/head&#62;
        &#60;body&#62;
            {% block header %}
                &#60;div id="header"&#62;
                    &#60;h1&#62;Tareas Symfony&#60;/h1&#62;
                    &#60;ul id="menu"&#62;
                        {% if app.user %}
                            &#60;li&#62;&#60;a href="{{ path('tasks') }}"&#62;Inicio&#60;/a&#62;&#60;/li&#62;
                            &#60;li&#62;&#60;a href="{{ path('my_tasks') }}"&#62;Mis tareas&#60;/a&#62;&#60;/li&#62;
                            &#60;li&#62;&#60;a href="{{ path('task_creation') }}"&#62;Crear tarea&#60;/a&#62;&#60;/li&#62;
                            
                            &#60;li class="right"&#62;&#60;a href="{{ path('logout') }}"&#62;Cerrar sesión&#60;/a&#62;&#60;/li&#62;
                            &#60;li class="right"&#62;&#60;a href=""&#62;{{ app.user.name ~ ' ' ~ app.user.surname }}&#60;/a&#62;&#60;/li&#62;
                        {% else %}
                            &#60;li&#62;&#60;a href="{{ path('login') }}"&#62;Login&#60;/a&#62;&#60;/li&#62;
                            &#60;li&#62;&#60;a href="{{ path('register') }}"&#62;Registro&#60;/a&#62;&#60;/li&#62;
                        {% endif %}
                    &#60;/ul&#62;
                &#60;/div&#62;
                &#60;div class="clearfix"&#62;&#60;/div&#62;   
            {% endblock %}
            {% block body %}{% endblock %}
            {% block javascripts %}{% endblock %}
        &#60;/body&#62;
    &#60;/html&#62;
    
    </pre>
    <h2 class="mt-1">Empezando la funcionalidad del login</h2>
    <p class="mt-1">Realizamos la siguiente configuración en 
        security.yaml
    </p>
    <pre class="prettyprint mt-1" style="width:1100px">
    security:
    encoders:
        App\Entity\User:
            algorithm: bcrypt
            cost: 4
    
    # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers
    # Incluimos el provider
    providers:
        in_memory: { memory: ~ }
        proveedor:
            entity:
                class: App\Entity\User
                property: email
    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        main:
            anonymous: true
            # definimos estas rutas de autenticación
            form_login:
                login_path: login
                check_path: login
                provider: proveedor
                
            logout:
                path: /logout
                target: /
    </pre>
    <p class="mt-1">Vamos al UserController</p>
    <pre class="prettyprint mt-1">
    // Incluimos
    use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;
    
    // Creamos el método
    public function login(AuthenticationUtils $authenticationUtils){
        $error = $authenticationUtils->getLastAuthenticationError();
    
        $lastUsername = $authenticationUtils->getLastUsername();
    
        return $this->render('user/login.html.twig', array(
            'error' => $error,
            'last_username' => $lastUsername
        ));
    }
    </pre>
    <p class="mt-1">Creamos la ruta</p>
    <pre class="prettyprint mt-1">
    login:
        path: /login
        controller: App\Controller\UserController::login
    
    # En logout no hay que definir un controlador porque es automatica
    logout:
        path: /logout       
    </pre>
    <p class="mt-1 w-50">
        Creamos una nueva vista en user/login.html.twig
    </p>
    <pre class="prettyprint mt-1" style="width: 1100px;">

    {% extends 'base.html.twig' %}

    {% block title %}Login de usuarios{% endblock %}
    
    {% block body %}
    &#60;div class="example-wrapper"&#62;
        &#60;h2&#62;Login de usuarios&#60;/h2&#62;
        
        {% if error %}
            &#60;div class="alert alert-error"&#62;
                {{ error.messagekey|trans(error.messageData, 'security') }}
            &#60;/div&#62;
        {% endif %}
        
        &#60;form action="{{ path('login') }}" method="POST"&#62;
            &#60;label for="username"&#62;Email&#60;/label&#62;
            &#60;input type="email" id="username" name="_username" value="{{ last_username }}" /&#62;
            
            &#60;label for="password"&#62;Contraseña:&#60;/label&#62;
            &#60;input type="password" id="password" name="_password" /&#62;
            
            &#60;div class="clearfix"&#62;&#60;/div&#62;
            
            &#60;input type="submit" value="Entrar" /&#62;
        &#60;/form&#62;
        
    &#60;/div&#62;
    {% endblock %}
        
    </pre>
    <h2 class="mt-1">Tareas</h2>
    <p class="mt-1 w-50">
        En templates/task/index.html.twig actualizamos lo siguiente:
    </p>
    <pre class="prettyprint mt-1">
        {% extends 'base.html.twig' %}

        {% block title %}Todas las tareas{% endblock %}
        
        {% block body %}
        
        &#60;div class="example-wrapper"&#62;
        &#60;h2>Todas las tareas ✅&#60;/h2&#62;
            {{ include('includes/task-list.html.twig') }}
         
        &#60;/div&#62;
        {% endblock %}
              
    </pre>
    <p class="mt-1">Creamos algunas vistas más</p>
    <p class="mt-1">Vista creation.html.twig</p>
    <pre class="prettyprint mt-1">
        {% extends 'base.html.twig' %}

        {% block title %}
            {% if edit is defined %}
                Editar tarea
            {%else%}
                Crear tarea
            {%endif%}
        
        {% endblock %}
        
        {% block body %}
        
        &#60;div class="example-wrapper"&#62;
            &#60;h2&#62;
                    {% if edit is defined %}
                        Editar tarea
                    {%else%}
                        Crear tarea
                    {%endif%}
            &#60;/h2&#62;
                {{ form_start(form) }}
                {{ form_widget(form) }}
                {{ form_end(form) }}
            &#60;/div&#62;
        {% endblock %}
        
    </pre>
    <p class="prettyprint mt-1">
        Vista detail.html.twig
    </p>
    <pre class="prettyprint mt-1">
    {% extends 'base.html.twig' %}

    {% block title %}Todas las tareas{% endblock %}
    
    {% block body %}
    
    &#60;div class="example-wrapper"&#62;
        &#60;h2&#62;{{task.title}} ✅&#60;/h2&#62;
        &#60;p class="data-task"&#62;
            {{task.user.name }} {{task.user.surname }} 
                | {{task.createdAt|date('d/m/Y h:i') }} | 
            {% if task.priority == 'high' %}
                    {{ 'Alta' }}
            {% endif %}
            {% if task.priority == 'medium' %}
                {{ 'Media' }}
            {% endif %}
            {% if task.priority == 'low' %}
                {{ 'Baja' }}
            {% endif %} 
                | {{task.hours}}h
        &#60;/p&#62;
        &#60;p&#62;
            {{task.content}}
        &#60;/p&#62;
        
    &#60;/div&#62;
    {% endblock %}        
    </pre>
    <p class="mt-1">Vista my-task.html.twig</p>
    <pre class="prettyprint mt-1">

    {% block title %}Todas las tareas{% endblock %}

    {% block body %}
    
    &#60;div class="example-wrapper"&#62;
        &#60;h2&#62;Mis tareas ✅&#60;/h2&#62;
        {{ include('includes/task-list.html.twig') }}
        
    &#60;/div&#62;
    {% endblock %}
    
    </pre>
    <p class="mt-1 w-50">Creamos en templates un folder con el siguiente archivo:
        templates/includes/task-list.html.twig
    </p>
    <pre class="prettyprint mt-1">
    {% if tasks|length &#62;= 1 %}
    &#60;table&#62;
        &#60;tr&#62;
            &#60;th&#62;Tarea&#60;/th&#62;
            &#60;th&#62;Prioridad&#60;/th&#62;
            &#60;th&#62;Horas presupuestadas&#60;/th&#62;
            &#60;th&#62;Acciones&#60;/th&#62;
        &#60;/tr&#62;
    
        {% for task in tasks %}
            &#60;tr&#62;
                &#60;td&#62;{{ task.title }}&#60;/td&#62;
                &#60;td&#62;
                    {% if task.priority == 'high' %}
                        {{ 'Alta' }}
                    {% endif %}
                    {% if task.priority == 'medium' %}
                        {{ 'Media' }}
                    {% endif %}
                    {% if task.priority == 'low' %}
                        {{ 'Baja' }}
                    {% endif %}
                &#60;/td&#62;
                &#60;td&#62;{{ task.hours }}&#60;/td&#62;
                &#60;td class="buttons"&#62;
                    &#60;a href="{{ path('task_detail', {'id':task.id}) }}" class="btn-show"&#62;Ver&#60;/a&#62;
                    
                    {% if app.user != null and task.user.id == app.user.id %}
                        &#60;a href="{{ path('task_edit', {'id':task.id}) }}" class="btn-edit"&#62;Editar&#60;/a&#62;
                        &#60;a href="{{ path('task_delete', {'id':task.id}) }}" class="btn-delete"&#62;Borrar&#60;/a&#62;
                    {% endif %}
                &#60;/td&#62;
            &#60;/tr&#62;
        {% endfor %}
    
    &#60;/table&#62;
    {% else %}
        &#60;strong&#62;No hay tareas disponibles en este momento&#60;/strong&#62;
    {% endif %}        
    </pre>
    <h2 class="mt-1">Actualizamos TaskController</h2>
    <pre class="prettyprint mt-1" style="width: 1100px;">

    namespace App\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\Routing\Annotation\Route;
    use Symfony\Component\HttpFoundation\Request;
    use App\Entity\Task;
    use App\Entity\User;
    use App\Form\TaskType;
    use Symfony\Component\Security\Core\User\UserInterface;
    
    class TaskController extends AbstractController
    {
    
        public function index()
        {
            // Prueba de entidades y relaciones
            $em = $this->getDoctrine()->getManager();
            $task_repo = $this->getDoctrine()->getRepository(Task::class);
            $tasks = $task_repo->findBy([], ['id' => 'DESC']);
            
            /*
            $user_repo = $this->getDoctrine()->getRepository(User::class);
            $users = $user_repo->findAll();
    
            foreach($users as $user){
                echo "&#60;h1&#62;{$user->getName()} {$user->getSurname()}&#60;/h1&#62;";
                
                foreach($user->getTasks() as $task){
                    echo $task->getTitle()."&#60;br/&#62;";
                }
            }
            * 
            */
            
            return $this->render('task/index.html.twig', [
                'tasks' => $tasks
            ]);
        }
        
        public function detail(Task $task){
            if(!$task){
                return $this->redirectToRout('tasks');
            }
            
            return $this->render('task/detail.html.twig',[
                'task' => $task
            ]);
        }
        
        public function creation(Request $request, UserInterface $user){
            $task = new Task();
            $form = $this->createForm(TaskType::class, $task);
            
            $form->handleRequest($request);
            
            if($form->isSubmitted() && $form->isValid()){
                $task->setCreatedAt(new \Datetime('now'));
                $task->setUser($user);
                
                $em = $this->getDoctrine()->getManager();
                $em->persist($task);
                $em->flush();
                
                return $this->redirect($this->generateUrl('task_detail', ['id' => $task->getId()]));
            }
            
            return $this->render('task/creation.html.twig',[
                'form' => $form->createView()
            ]);
        }
        
        public function myTasks(UserInterface $user){
            $tasks = $user->getTasks();
                    
            return $this->render('task/my-tasks.html.twig',[
                'tasks' => $tasks 
            ]);	
        }
        
        public function edit(Request $request, UserInterface $user, Task $task){
            if(!$user || $user->getId() != $task->getUser()->getId()){
                return $this->redirectToRoute('tasks');
            }
            
            $form = $this->createForm(TaskType::class, $task);
            
            $form->handleRequest($request);
            
            if($form->isSubmitted() && $form->isValid()){
                //$task->setCreatedAt(new \Datetime('now'));
                //$task->setUser($user);
                
                $em = $this->getDoctrine()->getManager();
                $em->persist($task);
                $em->flush();
                
                return $this->redirect($this->generateUrl('task_detail', ['id' => $task->getId()]));
            }
            
            return $this->render('task/creation.html.twig',[
                'edit' => true,
                'form' => $form->createView()
            ]);
        }
        
        public function delete(UserInterface $user, Task $task){
            if(!$user || $user->getId() != $task->getUser()->getId()){
                return $this->redirectToRoute('tasks');
            }
            
            if(!$task){
                return $this->redirectToRout('tasks');
            }
            
            $em = $this->getDoctrine()->getManager();
            $em->remove($task);
            $em->flush();
            
            return $this->redirectToRoute('tasks');
        }
        
            
    }
    
    </pre>
    <h2 class="prettyprint mt-1">
        Actualizamos el archivo de rutas
    </h2>
    <pre class="prettyprint mt-1">
    tasks:
        path: /tareas
        controller: App\Controller\TaskController::index
    
    task_detail:
        path: /tarea/{id}
        controller: App\Controller\TaskController::detail
    
    task_creation:
        path: /crear-tarea
        controller: App\Controller\TaskController::creation
        
    my_tasks:
        path: /mis-tareas
        controller: App\Controller\TaskController::myTasks
        
    task_edit:
        path: /editar-tarea/{id}
        controller: App\Controller\TaskController::edit
        
    task_delete:
        path: /borrar-tarea/{id}
        controller: App\Controller\TaskController::delete
        
    register:
        path: /registro
        controller: App\Controller\UserController::register
        
    login:
        path: /
        controller: App\Controller\UserController::login
        
    logout:
        path: /logout
    
    </pre>
    <h2 class="prettyprint mt-1">
        Creamos un formulario para las tareas
    </h2>
    <p class="mt-1">
        Creamos src/Form/TaskType.php
    </p>
    <pre class="prettyprint mt-1">
    
    namespace App\Form;
    
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    
    class TaskType extends AbstractType{
        
        public function buildForm(FormBuilderInterface $builder, array $options){
            $builder->add('title', TextType::class, array(
                'label' => 'Titulo'
            ))
            ->add('content', TextareaType::class, array(
                'label' => 'Contenido'
            ))
            ->add('priority', ChoiceType::class, array(
                'label' => 'Prioridad',
                'choices' => array(
                    'Alta' => 'high',
                    'Media' => 'medium',
                    'Baja' => 'low'
                )
            ))
            ->add('hours', TextType::class, array(
                'label' => 'Horas presupuestadas'
            ))
            ->add('submit', SubmitType::class, array(
                'label' => 'Guardar'
            ));
        }
        
    }
    </pre>
    <h2 class="mt-1">Control de Acceso</h2>
    <p class="mt-1 w-50">Sirve para restringir el acceso a ciertas rutas. Lo
        configuramos en security.yaml
        Esto se hace en: access_control
    </p>
    <pre class="prettyprint mt-1" style="width: 1100px;">
        security:
        encoders:
            App\Entity\User:
                algorithm: bcrypt
                cost: 4
        
        # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers
        providers:
            in_memory: { memory: ~ }
            proveedor:
                entity:
                    class: App\Entity\User
                    property: email
        firewalls:
            dev:
                pattern: ^/(_(profiler|wdt)|css|images|js)/
                security: false
            main:
                anonymous: true
                form_login:
                    login_path: login
                    check_path: login
                    provider: proveedor
                    
                logout:
                    path: /logout
                    target: /
    
                # activate different ways to authenticate
    
                # http_basic: true
                # https://symfony.com/doc/current/security.html#a-configuring-how-your-users-will-authenticate
    
                # form_login: true
                # https://symfony.com/doc/current/security/form_login_setup.html
    
        # Easy way to control access for large sections of your site
        # Note: Only the *first* access control that matches will be used
        access_control:
             - { path: ^/tareas, roles: ROLE_USER }
             - { path: ^/tarea, roles: ROLE_USER }
             - { path: ^/crear-tarea, roles: ROLE_USER }
             - { path: ^/mis-tareas, roles: ROLE_USER }
             - { path: ^/editar-tarea, roles: ROLE_USER }
             - { path: ^/borrar-tarea, roles: ROLE_USER }
    
    </pre>
    <h2 class="mt-1">Apuntes ORM Doctrine</h2>
    <pre class="prettyprint mt-1" style="width: 1100px;">

    // Crear la base de datos según el nombre pasado
    // en el archivo .env
    php bin/console doctrine:database:create

    // Dadas tablas en base de datos, generar las entidades

    php bin/console doctrine:mapping:import App\\Entity annotation --path=src/Entity

    // Generar los getters y setter faltantes
    php bin/console make:entity --regenerate App

    // Generar la Entidad y luego las tablas
    // Generar la Entidad
    php bin/console make:entity Usuario
    o 
    php bin/console. make:entity
    y seguir el intérprete

    // Generar la tabla desde la Entidad
    php bin/console doctrine:migrations:diff
    // El comando de arriba revisa las diferencias
    // entre las entidades y la base de datos y genera
    // la migración correspondiente

    //Ejecutar las migraciones en la base de datos
    php bin/console doctrine:migrations:migrate

    // Sql desde consola
    php bin/console doctrine:query:sql "SELECT * FROM users"

    Doctrine
    QueryBuilder
    https://symfony.com/doc/current/doctrine.html
    Dql
    https://parasitovirtual.wordpress.com/2011/03/23/introduccion-dql-doctrine-query-language/

    // Los repositorios sirven para guardar las lógicas de
    // las consultas haciendo un código mas mantenible
    </pre>
    <h1>Documentación: API con Symfony</h1>
    <p class="mt-1">Instalar las anotaciones:</p>
    <p class="single-code mt-1">docker run --rm -it -v "$(pwd)":/app composer composer require annotations</p>
    <p class="mt-1">En config/ se creará el archivo: annotations.yaml</p>
    <p class="mt-1">En este archivo se definen dónde se usarán las anotaciones.
        En general, puede quedar con la configuración por defecto.
    </p>

    <h2 class="mt-1">Primera ruta</h2>
    <p class="mt-1">Crear en /src el archivo LibraryController.php</p>
    
    <pre class="prettyprint mt-1">

    &#60;?php

    namespace App\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Annotation\Route;
    

    class LibraryController extends AbstractController
    {
        /**
         * @Route("/books", name="books_get")
         */
        public function list()
        {
            $response = new Response();
            $response->setContent('&#60;h1&#62;Hola Mundo&#60;/h1&#62;');
            return $response;
        }
    }
        

    </pre>

    <p class="mt-1">Devolver un Json</p>
    <pre class="prettyprint mt-1">
    &#60;?php

    namespace App\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\Routing\Annotation\Route;
    
    
    
    class LibraryController extends AbstractController
    {
        /**
         * @Route("/library/list", name="library_list")
         */
        public function list()
        {
            $response = new JsonResponse();
            $response->setData([
                [
                    'id' => 1,
                    'title' => 'Don Quijote'
                ],
                [
                    'id' => 2,
                    'title' => 'Harry Potter'
                ]
            ]
            );
            return $response;
        }
    }
        
    </pre>

    <h2 class="mt-1">Trabajar con Bases de Datos - Doctrine</h2>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer require symfony/orm-pack
    </p>
    <p class="mt-1">El comando anterior realiza las siguientes modificaciones:</p>
    <p class="mt-1">Agrega la siguiente variable de entorno al archivo .env</p>
    <p class="single-code mt-1">
        DATABASE_URL=mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7
    </p>
    <p class="mt-1">Se crean las carpetas: Entity, Migrations y Repository</p>
    <p class="mt-1">En /config/packages se crean los archivos de configuración: doctrine_migrations.yaml y doctrine.yaml</p>

    <h2 class="mt-1">Crear las entidades</h2>
    <p class="mt-1">Instalar el bundle (no necesario, pero recomendado):</p>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer require --dev symfony/maker-bundle
    </p>
    <p class="mt-1">Crear la base de datos. Yo lo defino en el docker-compose.yml</p>
    <h3 class="mt-1">Crear la entidad Libro</h3>
    <p class="mt-1">Buscar el contenedor de la imagen php utilizada en el proyecto. Luego de levantar el proyecto.</p>
    <p class="single-code mt-1">docker ps</p>
    <p class="mt-1">Utilizar la consola para crear la Entidad:</p>
    <p class="single-code mt-1">
        docker exec -it php-symfony bin/console make:entity
    </p>
    <p class="mt-1">Donde php-symfony es el nombre del contenedor php docker</p>
    <p class="mt-1">Seguir las instrucciones de la consola interactiva para definir la entidad</p>
    <p class="mt-1">Se creará el archivo Book.php en /src/Entity</p>
    <h2 class="mt-1">Migraciones</h2>
    <p class="mt-1 w-50 text-justify">En la sección anterior, se definieron las Entidades, pero
        eso es a nivel archivos de php. Ahora hay que ejecutar un método que toma
        la definición de las entidades y crea un script que posteriormente servirá
        para pasar nuestro modelo de Entidades a la bases de datos. Esto es lo que
        se conoce como "Migración". Es un control de versiones para las bases de datos.
    </p>
    <p class="mt-1">Generar la migración</p>
    <p class="single-code mt-1">
        docker exec -it php-symfony bin/console make:migration
    </p>
    <p class="mt-1">Con el comando anterior se creó el archivo de migración.</p>
    <p class="mt-1 w-50">Pero para que los cambios se propaguen a la base de datos. 
        Se debe ejecutar el siguiente comando. Es decir, correr la migración.
    </p>
    <p class="single-code mt-1">
        docker exec -it php-symfony bin/console doctrine:migrations:migrate
    </p>

    <h2 class="mt-1">Crear un nuevo libro, método</h2>
    <p class="mt-1">En LibraryController.php agregar el siguiente método:</p>
    <p class="mt-1">Es un método get, se invoca así, por ejemplo:</p>
    <p class="single-code mt-1">
        http://localhost/book/create?title=Don Quijote
    </p>
    <pre class="prettyprint mt-1">
    &#60;?php

    namespace App\Controller;
    
    use App\Entity\Book;
    use App\Repository\BookRepository;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\Routing\Annotation\Route;
    use Symfony\Component\HttpFoundation\Request;
    use Doctrine\ORM\EntityManagerInterface;
    
    
    
    class LibraryController extends AbstractController
    {
        /**
          * @Route("/books", name="books_get")
          */
        public function list(Request $request,
                                BookRepository $bookRepository
        )
        {
            $books = $bookRepository->findAll();
            $booksAsArray = [];
            foreach($books as $book){
                $booksAsArray[] = [
                    'id' => $book->getId(),
                    'title' => $book->getTitle()
                ];
            }
            $response = new JsonResponse();
            $response->setData([
                'success' => true,
                'data' => $booksAsArray
            ]
            );
            return $response;
        }
    
        /**
          * @Route("/book/create", name="create_book")
          */
        public function createBook(Request $request,
                                    EntityManagerInterface $em)
        {
            $book = new Book();
            $response = new JsonResponse();
            $title = $request->get('title', null);
            if(empty($title)){
                $response->setData([
                    'success' => false,
                    'error' => 'Title cannot be empty',
                    'data' => null
                ]);
            }
            $book->setTitle($title);
            $em->persist($book);
            $em->flush();
            $response->setData([
                'success' => true,
                'data' => [
                    [
                        'id' => $book->getId(),
                        'title' => $book->getTitle()
                    ]
                ]
            ]);
            return $response;
        }
    } 
    </pre>
    
    <h2 class="mt-1">Cambio en método list</h2>
    <p class="mt-1">Ahora extrae los libros de la base de datos</p>
    <pre class="prettyprint mt-1">
    &#60;?php

    namespace App\Controller;
    
    use App\Entity\Book;
    use App\Repository\BookRepository;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\Routing\Annotation\Route;
    use Doctrine\ORM\EntityManagerInterface;
    
    
    
    class LibraryController extends AbstractController
    {
        /**
         * @Route("/books", name="books_get")
         */
        public function list(Request $request,
                                BookRepository $bookRepository
        )
        {
            $books = $bookRepository->findAll();
            $booksAsArray = [];
            foreach($books as $book){
                $booksAsArray[] = [
                    'id' => $book->getId(),
                    'title' => $book->getTitle()
                ];
            }
            $response = new JsonResponse();
            $response->setData([
                'success' => true,
                'data' => $booksAsArray
            ]
            );
            return $response;
        }
    
        /**
         * @Route("/book/create", name="create_book")
         */
        public function createBook(Request $request,
                                    EntityManagerInterface $em)
        {
            $book = new Book();
            $response = new JsonResponse();
            $title = $request->get('title', null);
            if(empty($title)){
                $response->setData([
                    'success' => false,
                    'error' => 'Title cannot be empty',
                    'data' => null
                ]);
            }
            $book->setTitle($title);
            $em->persist($book);
            $em->flush();
            $response->setData([
                'success' => true,
                'data' => [
                    [
                        'id' => $book->getId(),
                        'title' => $book->getTitle()
                    ]
                ]
            ]);
            return $response;
        }
    }
    </pre>

    <h1 class="mt-1">FOS Rest Bundle</h1>
    <p class="mt-1 w-50">Todo lo anterior fue para entender el funcionamiento
        de las API en Symfony. Ahora utilizaremos una librería dedicada
        para el manejo de API's. La librería es: FOS Rest Bundle.
    </p>
    <h2 class="mt-1">Instalar Serializer</h2>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer symfony/serializer-pack
    </p>
    <p class="mt-1">Luego hay que configurar el Serializer</p>
    <p class="mt-1">En config/package/framework.yaml copiar lo siguiente:</p>
    <pre class="bg-gray mt-1 w-50">

    serializer:
        enabled: true
        mapping:
            paths: ['%kernel.project_dir%/config/serializer']
    </pre>
    <p class="mt-1 w-50">El código de arriba le dice al framework,
        dónde encontrará la información para mappear las entidades
    </p>
    <p class="mt-1">Ahora creamos en /config las carpetas
        serializer/Entity
    </p>
    <p class="mt-1 w-50">Creamos un archivo serializer/Entity/Book.yaml para 
        definir el mapeo.
    </p>
    <p class="mt-1">En Book.yaml escribimos lo siguiente:</p>
    <pre class="bg-gray mt-1 w-50">

        App\Entity\Book:
            attributes:
                id:
                    groups: ['book']
                title:
                    groups: ['book']
    </pre>
    <h2 class="mt-1">Instalando FOS Rest Bundle</h2>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer require friendsofsymfony/rest-bundle
    </p>
    <h2 class="mt-1">Rutas</h2>
    <p class="mt-1">En config/routes crear api.yaml</p>
    <pre class="bg-gray mt-1 w-50">

    api:
        resource: ../../src/Controller/Api
        type: annotation
        prefix: /api
    </pre>
    <p class="mt-1">Todas las rutas que esten en src/Controller/Api tendrán
        automáticamente el prefijo /api
    </p>
    <h2 class="mt-1">Configuramos config/packages/fos_rest.yaml</h2>
    <pre class="prettyprint mt-1" style="width: 900px;">
    fos_rest:
    param_fetcher_listener: true
    view:
        empty_content: 200
        view_response_listener: true
        failed_validation: HTTP_BAD_REQUEST
        formats:
            json: true
            xml: false
    body_listener:
        decoders:
            json: fos_rest.decoder.json
    format_listener:
        rules:
            - { path: '/api', priorities: ['json'], fallback_format: json, prefer_extension: false }
            - { path: '^/', stop: true, fallback_format:  html }
    exception:
        enabled: true
    serializer:
        serialize_null: true
    </pre>
    <p class="mt-1 w-50">La configuración "view" lo que hace es que en el controlador
        podamos devolver la entidad simplemente sin hacer una conversión a JSON,
        ya que la librería se encarga de eso.
    </p>
    <p class="mt-1 w-50">En "rules" se especifica que solo maneje las rutas que
        empiecen con /api también se pueden excluir rutas
    </p>
    <h2 class="mt-1">Instalar el Validator</h1>
<p class="single-code mt-1" style="width: 900px;">
    docker run --rm -it -v "$(pwd)":/app composer composer require symfony/validator twig doctrine/annotations
</p>
<p class="mt-1 w-50">Creamos la carpeta src/Controller/Api y el archivo 
    src/Controller/Api/BooksController.php con el siguiente código:
</p>
<pre class="prettyprint mt-1" style="width: 900px;">
    &#60;?php

    namespace App\Controller\Api;
    
    use App\Repository\BookRepository;
    use App\Entity\Book;
    use Doctrine\ORM\EntityManagerInterface;
    use FOS\RestBundle\Controller\AbstractFOSRestController;
    use FOS\RestBundle\Controller\Annotations as Rest;
    
    
    class BooksController extends AbstractFOSRestController
    {
        /**
         * @Rest\Get(path="/books")
         * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
         */
        public function getAction(BookRepository $bookRepository)
        {
            return $bookRepository->findAll();
        }
    
        /**
         * @Rest\Post(path="/books")
         * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
         */
        public function PostActions(EntityManagerInterface $em)
        {
            $book = new Book();
            $book->setTitle('Installing FOS Rest Bundle');
            $em->persist($book);
            $em->flush();
            return $book;
        }
    }
    
</pre>
    <h2 class="mt-1">Formularios</h2>
    <p class="mt-1 w-50">Para manejar las request utilizaremos un componente para 
        formularios de Symfony.
    </p>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer symfony/form
    </p>
    <p class="mt-1">Creamos las carpetas: src/Form/Type</p>
    <p class="mt-1 w-50">Dentro creamos el archivo BookFormType.php con el siguiente código
        que define los campos del formulario.
    </p>
    <pre class="prettyprint mt-1" style="width: 800px;">
    &#60?php

    namespace App\Form\Type;
    
    use App\Entity\Book;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    
    
    class BookFormType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder,
                                    array $options)
        {
            $builder->add('title', TextType::class);
        }
    
        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Book::class,
            ]);
        }
    
        /* Los siguientes métodos getBlockPrefix y getName se definen para evitar tener 
           que darle un nombre al formulario al hacer la llamada al endpoint,
           quedando una request más limpia 
         */
    
        public function getBlockPrefix()
        {
            return '';
        }
    
        public function getName()
        {
            return '';
        }
    }
    </pre>
    <p class="mt-1">
        Ahora, en BooksController.php incluimos la lógica del formulario en el método postActions
    </p>
    <pre class="prettyprint mt-1" style="width: 800px;">
    &#60;?php

    namespace App\Controller\Api;
    
    use App\Repository\BookRepository;
    use App\Entity\Book;
    use App\Form\Type\BookFormType;
    use Symfony\Component\HttpFoundation\Request;
    use Doctrine\ORM\EntityManagerInterface;
    use FOS\RestBundle\Controller\AbstractFOSRestController;
    use FOS\RestBundle\Controller\Annotations as Rest;
    
    
    class BooksController extends AbstractFOSRestController
    {
        /**
          * @Rest\Get(path="/books")
          * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
          */
        public function getAction(BookRepository $bookRepository)
        {
            return $bookRepository->findAll();
        }
    
        /**
          * @Rest\Post(path="/books")
          * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
          */
        public function PostActions(EntityManagerInterface $em,
                                    Request $request)
        {
            $book = new Book();
            $form = $this->createForm(BookFormType::class, $book);
            $form->handleRequest($request);
            if($form->isSubmitted() && $form->isValid()){
                $em->persist($book);
                $em->flush();
                return $book;
            }
            return $form;
        }
    }
    </pre>
    <h2 class="mt-1">Configuración del Validator</h2>
    <p class="mt-1 w-50">Más arriba habíamos instalado el componente Validator.
        Ahora vamos a configurar las validaciones para el formulario.
    </p>
    <p class="mt-1 w-50">Creamos la carpeta /config/validator y 
        dentro el archivo: Book.yaml</p>
    <pre class="prettyprint mt-1" style="width: 800px;">

    App\Form\Model\BookDTO:
    properties:
        title:
            - NotBlank: ~
            - Length:
                min: 3
                max: 250
                minMessage: 'The title must be at least {{ limit }} characters long'
                maxMessage: 'The title cannot be longer than {{ limit }} characters'
                allowEmptyString: false
    
    </pre>
    
    <h1 class="single-code mt-1 bg-black text-white" style="width:800px;">
        JWT en Symfony
    </h1>
    <p class="mt-1">Hacemos una instalación de Symfony para API</p>
    <p class="mt-1">Luego instalamos los siguientes paquetes:</p>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer symfony/security-core symfony/uid
    </p>
    <p class="mt-1 w-50">El primero es el componente de seguridad para Symfony y el segundo
        permite crear Unique User Id
    </p>
    <p class="mt-1">Instalamos el orm</p>  
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer require orm
    </p>
    <p class="mt-1">Crear el archivo src/Entity/User.php</p>
    <pre class="prettyprint mt-1">
    &#60;?php

    declare(strict_types=1);
    
    namespace App\Entity;
    
    use Symfony\Component\Security\Core\User\UserInterface;
    use Symfony\Component\Uid\Uuid;
    
    //use Symfony\Component\Security\Core\User\User;
    
    class User implements UserInterface
    {
        private string $id;
        private string $name;
        private string $email;
        private string $password;
        private \DateTime $createdAt;
        private \DateTime $updatedAt;
    
        public function __construct(string $name, Email $email, string $password)
        {
            $this->id = Uuid::v4()->toRfc4122();
            $this->name = $name;
            $this->setEmail($email);
            $this->password = $password;
            $this->createdAt = new \DateTime();
            $this->markAsUpdated();
        }
    
        public function getId(): string
        {
            return $this->id;
        }
    
        public function getName(): string
        {
            return $this->name;
        }
    
        public function setName(string $name): void
        {
            $this->name = $name;
        }
    
        public function getEmail(): string
        {
            return $this->email;
        }
    
        public function setEmail(Email $email): void
        {
            if(!\filter_var($email, \FILTER_VALIDATE_EMAIL)){
                throw new \LogicException('Invalid email');
            }
            $this->email = $email;
        }
    
        public function getPassword(): string
        {
            return $this->password;
        }
    
        public function setPassword(string $password): void
        {
            $this->password = $password;
        }
    
        public function getCreatedAt(): \DateTime
        {
            return $this->createdAt;
        }
    
        public function getUpdatedAt(): \DateTime
        {
            return $this->updatedAt;
        }
    
        public function markAsUpdated(): void
        {
            $this->updatedAt = new \DateTime();
        }
    
        public function getRoles(): array
        {
            return [];
        }
    
        public function getSalt(): void
        {
    
        }
    
        public function getUsername(): string
        {
            return $this->email;
        }
    
        public function eraseCredentials(): void
        {
            
        }
    
    }
    </pre>
    <p class="mt-1">Mappear la entidad con Doctrine</p>
    <p class="mt-1 w-50">En /config/packages/doctrine.yaml configurar lo siguiente:</p>
    <pre class="prettyprint mt-1">
    doctrine:
    dbal:
        url: '%env(resolve:DATABASE_URL)%'

        # IMPORTANT: You MUST configure your server version,
        # either here or in the DATABASE_URL env var (see .env file)
        #server_version: '13'
    orm:
        auto_generate_proxy_classes: true
        naming_strategy: doctrine.orm.naming_strategy.underscore_number_aware
        auto_mapping: true
        mappings:
            App:
                is_bundle: false
                type: xml 
                dir: '%kernel.project_dir%/config/orm/mapping'
                prefix: 'App\Entity'
                alias: App
    </pre>
    <p class="mt-1 text-justify w-50">Lo importante de esta configuración es que
        se indica dónde está la configuración del mapping,
        que se hará con xml en el folder /config/orm/mapping
    </p>
    <p class="mt-1">Creamos las carpetas /config/orm/mapping y dentro el fichero
        User.orm.xml
    </p>
    <pre class="prettyprint mt-1" style="width: 800px;">
    &#60;?xml version="1.0" encoding="UTF-8" ?&#62;
    &#60;doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"&#62;
        &#60;entity name="App\Entity\User" table="user"&#62;
            &#60;id name="id" type="string" length="36"/&#62;
    
            &#60;field name="name" length="100"/&#62;
            &#60;field name="email" length="100"/&#62;
            &#60;field name="password" length="100"/&#62;
            &#60;field name="createdAt" type="datetime"/&#62;
            &#60;field name="updatedAt" type="datetime"/&#62;
    
            &#60;lifecycle-callbacks&#62;
                &#60;lifecycle-callback type="preUpdate" method="markAsUpdated"/&#62;
            &#60;/lifecycle-callbacks&#62;
        &#60;/entity&#62;
    &#60;/doctrine-mapping&#62;
    </pre>
    <p class="mt-1">Creamos el archivo /src/Repository/Entity/BaseRepository.php</p>
    <pre class="prettyprint mt-1" style="width: 900px;">
    &#60;?php

    declare(strict_types=1);
    
    namespace App\Repository;
    
    use Doctrine\Persistence\ManagerRegistry;
    use Doctrine\DBAL\Connection;
    use Doctrine\ORM\EntityManager;
    use Doctrine\ORM\OptimisticLockException;
    use Doctrine\ORM\ORMException;
    use Doctrine\Persistence\ObjectManager;
    use Doctrine\Persistence\ObjectRepository;
    
    abstract class BaseRepository
    {
        private ManagerRegistry $managerRegistry;
        protected Connection $connection;
        protected ObjectRepository $objectRepository;
    
        public function __construct(ManagerRegistry $managerRegistry, Connection $connection)
        {
            $this->managerRegistry = $managerRegistry;
            $this->connection = $connection;
            $this->objectRepository = $this->getEntityManager()->getRepository($this->entityClass());
        }
    
        abstract protected static function entityClass(): string;
    
        /**
          * @throws ORMException
          * @throws OptimisticLockException
          */
        protected function saveEntity(object $entity): void
        {
            $this->getEntityManager()->persist($entity);
            $this->getEntityManager()->flush();
        }
    
        /**
          * @return ObjectManager|EntityManager
          */
        public function getEntityManager()
        {
            $entityManager = $this->managerRegistry->getManager();
    
            if ($entityManager->isOpen()) {
                return $entityManager;
            }
    
            return $this->managerRegistry->resetManager();
        }
    }
    </pre>
    <p class="mt-1">Creamos el archivo src/Repository/UserRepository.php</p>
    <pre class="prettyprint mt-1" style="width: 900px;">
    &#60;?php

    declare(strict_types=1);
    
    namespace App\Repository;
    
    use App\Entity\User;
    use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
    
    class UserRepository extends BaseRepository
    {
        protected static function entityClass(): string
        {
            return User::class;
        }
    
        public function findOneByEmailOrFail(string $email): User
        {
            if(null === $user = $this->objectRepository
                                        ->findOneBy(['email' => $email])
            )
            {
                throw new NotFoundHttpException(\sprintf('User %s not found', $email));
            }
            return $user;
        }
    
        public function save(User $user): void
        {
            $this->saveEntity($user);
        }
    }
    </pre>
    <p class="mt-1">Generamos una migración</p>
    <p class="single-code mt-1">
        docker exec -it php-symfony bin/console d:m:g
    </p>
    <p class="mt-1">En el archivo de migraciones copiamos lo siguiente:</p>
    <pre class="prettyprint mt-1">
    &#60;?php

    declare(strict_types=1);
    
    namespace DoctrineMigrations;
    
    use Doctrine\DBAL\Schema\Schema;
    use Doctrine\Migrations\AbstractMigration;
    
    /**
      * Auto-generated Migration: Please modify to your needs!
      */
    final class Version20210130171518 extends AbstractMigration
    {
        public function getDescription() : string
        {
            return 'Creates `user` table';
        }
    
        public function up(Schema $schema) : void
        {
            $this->addSql("
                CREATE TABLE `user`(
                    id CHAR(36) NOT NULL PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    email VARCHAR(100) NOT NULL,
                    password VARCHAR(100) NOT NULL,
                    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    INDEX IDX_email (email),
                    CONSTRAINT U_EMAIL UNIQUE KEY (email)
                    )ENGINE=InnoDB;
            ");
    
        }
    
        public function down(Schema $schema) : void
        {
            $this->addSql("DROP TABLE `user`");
        }
    }
    </pre>
    <p class="mt-1">Ejecutamos las migraciones</p>
    <p class="mt-1">Los cambios habrán impactado en la base de datos</p>
    <p class="single-code mt-1">
        docker exec -it php-symfony bin/console d:m:m -m
    </p>
    <h2>Instalamos JWT</h2>
    <p class="mt-1">
        Librería: https://github.com/lexik/LexikJWTAuthenticationBundle
    </p>
    <p class="single-code mt-1">
        docker run --rm -it -v "$(pwd)":/app composer composer require lexik/jwt-authentication-bundle
    </p>
    <p class="mt-1">Se crearán unas variables en el .env</p>
    <pre class="bg-gray w-50 mt-1">

    ###&#62; lexik/jwt-authentication-bundle ###
    JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
    JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
    JWT_PASSPHRASE=bbbe34e0b3bca793c712401737ce37db
    ###&#60; lexik/jwt-authentication-bundle ###

    </pre>
    <p class="mt-1 w-50">Incluimos la duración del token. En este
        caso elegimos 60 días
    </p>
    <pre class="bg-gray w-50 mt-1">

    ###&#62; lexik/jwt-authentication-bundle ###
    JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
    JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
    JWT_PASSPHRASE=bbbe34e0b3bca793c712401737ce37db
    JWT_TOKEN_TTL=5184000 # 60 days
    ###&#60; lexik/jwt-authentication-bundle ###
    
    </pre>
    <p class="mt-1 w-50">En /config/package/lexik_jwt_authentication.yaml
        agregamos ese valor también:
    </p>
    <pre class="bg-gray w-50 mt-1">
    
    lexik_jwt_authentication:
        secret_key: '%env(resolve:JWT_SECRET_KEY)%'
        public_key: '%env(resolve:JWT_PUBLIC_KEY)%'
        pass_phrase: '%env(resolve:JWT_PASSPHRASE)%'
        token_ttl: '%env(resolve:JWT_TOKEN_TTL)%'    
    </pre>
    <h2 class="mt-1">Generamos las clave pública y privada:</h2>
    <pre class="bg-gray w-50 mt-1" style="width: 1000px;">

    mkdir -p config/jwt
    openssl genrsa -passout pass:bbbe34e0b3bca793c712401737ce37db -out config/jwt/private.pem -aes256 4096
    openssl rsa -pubout -passin pass:bbbe34e0b3bca793c712401737ce37db -in config/jwt/private.pem -out config/jwt/public.pem       
    </pre>
    <p class="mt-1">Si ocurre algún error debemos revisar los permisos de la carpeta config/jwt y
        del archivo private.pem en especial. Notar que el pass es el pass_phrase.
    </p>
    <h2 class="mt-1">UserProvider</h2>
    <p class="mt-1 w-50">
        Creamos una clase para que implemente el security-core de Symfony para 
        poder extraer información del token e identificar al usuario
    </p>
    <p class="mt-1 w-50">Es un cambio que se realiza sobre la clase User en Entity.
        Acá el cambio ya lo hemos hecho anteriormente, se trata de extender de UserInterface
    </p>
    <p class="mt-1 w-50">Creamos la siguiente estructura de carpetas para alojar al UserProvider:
        src/Security/Core/User y creamos la clase UserProvider.php
    </p>
    <pre class="prettyprint mt-1" style="width: 900px;">
    &#60;?php

    declare(strict_types=1);
    
    namespace App\Security\Core\User;
    
    use App\Repository\UserRepository;
    use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
    use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
    use Symfony\Component\Security\Core\Exception\UsernameNotFoundException;
    use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
    use Symfony\Component\Security\Core\User\UserInterface;
    use Symfony\Component\Security\Core\User\UserProviderInterface;
    
    class UserProvider implements UserProviderInterface, PasswordUpgraderInterface
    {
        private UserRepository $userRepository;
    
        public function __construct(UserRepository $userRepository)
        {
            $this->userRepository = $userRepository;
        }
    
        public function loadUserByUsername(string $username): UserInterface
        {
            try{
                return $this->userRepository->findOneByEmailOrFail($username);
            }catch(NotFoundHttpException $e){
                throw new UsernameNotFoundException(\sprintf("User with email %s not found", $username));
            }
        }
    
        public function refreshUser(UserInterface $user): UserInterface
        {
            if(!$user instanceof User){
                throw new UnsupportedUserException(\sprintf("Instances of %s are not suported",
                                                    \get_class($user)));
            }
    
            return $this->loadUserByUsername($user->getUsername());
        }
    
        public function upgradePassword(UserInterface $user, string $newEncodedPassword): void
        {
            $user->setPassword($newEncodedPassword);
    
            $this->userRepository->save($user);
        }
    
        public function supportsClass(string $class): bool
        {
            return User::class === $class;
        }
    }
    </pre>
    <h2 class="mt-1">Configuramos config/packages/security.yaml</h2>
    <pre class="prettyprint mt-1" style="width:1000px;">
    security:
        # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers
        encoders:
            App\Entity\User:
                algorithm: auto
        providers:
            user_provider:
                id: App\Security\Core\User\UserProvider
        firewalls:
            login:
                pattern: ^/api/login
                stateless: true
                anonymous: true
                json_login:
                    check_path: /api/login_check
                    success_handler: lexik_jwt_authentication.handler.authentication_success
                    failure_handler: lexik_jwt_authentication.handler.authentication_failure
    
            api:
                pattern:   ^/api
                stateless: true
                guard:
                    authenticators:
                        - lexik_jwt_authentication.jwt_token_authenticator
    
        access_control:
            - { path: ^/api/login, roles: IS_AUTHENTICATED_ANONYMOUSLY }
            - { path: ^/api,       roles: IS_AUTHENTICATED_FULLY }
    
    </pre>
    <h2 class="mt-1">Configuramos ruta para autenticar al usuario</h2>
    <p class="mt-1">En /config/routes.yaml</p>
    <pre class="bg-gray mt-1 w-50">

    api_login_check:
        path: /api/login_check
    </pre>
    <p class="mt-1">Creamos un usuario para probar como se explica en
        el minuto 5:00 del siguiente <a target="_blanck" href="https://youtu.be/j52_F_IOAOM?list=PLWpsZlKx38t-w74Pv7hK_qxPRLi6NLXt3" rel="nofollow">Video</a>
    </p>
    <p class="mt-1 w-50">Hacemos una llamada como indica la documentación de la librería</p>
    <p class="mt-1">Nos devolverá algo como esto:</p>
    <pre class="bg-gray mt-1 w-50">

        {
            "token" : "valorAlfanumerico"
        }
    </pre>
    <p class="mt-1 w-50">Podemos configurar que datos mandamos en el token de la siguiente manera:</p>
    <p class="mt-1 w-50">Creamos una carpeta src/Api/Listener y dentro el archivo: JWTCreatedListener.php</p>
    <pre class="prettyprint mt-1">
    &#60;?php

    declare(strict_types=1);
    
    namespace App\Controller\Api\Listener;
    
    use Lexik\Bundle\JWTAuthenticationBundle\Event\JWTCreatedEvent;
    
    class JWTCreatedListener
    {
        public function onJWTCreated(JWTCreatedEvent $event): void
        {
            $user = $event->getUser();
    
            $payload = $event->getData();
            unset($payload['roles']);
            $payload['userId'] = $user->getId();
    
            $event->setData($payload);
        }
    }
    </pre>
    <p class="mt-1 w-50">Configuramos config/services.yaml agregando las últimas
        líneas
    </p>
    <pre class="prettyprint mt-1" style="width: 1100px;">
    parameters:

    services:
        _defaults:
            autowire: true
            autoconfigure: true
    
        App\:
            resource: '../src/*'
            exclude: '../src/{DependencyInjection,Entity,Migrations,Tests,Kernel.php}'
    
        App\Controller\:
            resource: '../src/Controller'
            tags: ['controller.service_arguments']
    
        App\Controller\Api\Listener\JWTCreatedListener:
            tags:
                - { name: kernel.event_listener, event: lexik_jwt_authentication.on_jwt_created, method: onJWTCreated }
    </pre>
    <p class="mt-1">Con eso queda terminada toda la configuración
        del JWT.
    </p>
    <p class="mt-1">En cada llamada a la API desde el cliente,
        se debe enviar en la cabecera el par: <br>
        Authorization : BEARER token
    </p>
    <p class="mt-1">Donde token es el token alfanumérico</p>
</article>


<script src="js/run_prettify.js"></script>
</body>
</html>